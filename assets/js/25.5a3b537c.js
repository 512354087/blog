(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{662:function(s,e,n){"use strict";n.r(e);var a=n(76),t=Object(a.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"虚拟-dom-的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom-的理解"}},[s._v("#")]),s._v(" 虚拟 DOM 的理解")]),s._v(" "),e("p",[s._v("本质上是 JavaScript 对象，这个对象就是更加轻量级的对 DOM 的描述\n对于 DOM 这么多属性，其实大部分属性对于做 Diff 是没有任何用处的，所以如果用更轻量级的 JS 对象来代替复杂的 DOM 节点，然后把对 DOM 的 diff 操作转移到 JS 对象，就可以避免大量对 DOM 的查询操作。这个更轻量级的 JS 对象就称为 Virtual DOM 。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("维护一个使用 JS 对象表示的 Virtual DOM，与真实 DOM 一一对应\n对前后两个 Virtual DOM 做 diff ，生成变更（Mutation）\n把变更应用于真实 DOM，生成最新的真实 DOM\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("可以看出，因为要把变更应用到真实 DOM 上，所以还是避免不了要直接操作 DOM ，但是 React 的 diff 算法会把 DOM 改动次数降到最低。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h2",{attrs:{id:"vue2-和-vue3-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue2-和-vue3-的区别"}},[s._v("#")]),s._v(" vue2 和 vue3 的区别")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("vue2的实现方式是通过Object.defineProperty来重新定义getter，setter方法实现的。\n新版的Vue3使用ES6的Proxy方式来解决这个问题。之前遇到的两个问题就简单的多了。首先Proxy是支持数组的也就是数组是不需要做特别的代码的。对于深层监听也不不必要使用递归的方式解决。当get是判断值为对象时将对象做响应式处理返回就可以了。大家想想这个并不不是发生在初始化的时候而是设置值得时候当然性能上得到很大的提升\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("h2",{attrs:{id:"关于接口请求放在那个生命周期的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于接口请求放在那个生命周期的"}},[s._v("#")]),s._v(" 关于接口请求放在那个生命周期的")]),s._v(" "),e("ul",[e("li",[s._v("vue")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("一般情况，我们将请求接口放在mounted中，mounted阶段，el已经挂载，可以操作DOM。\ncreated阶段也可以做一些简单的请求（不操作DOM）\n注意：如果是服务端渲染，需要放到created中。因为只支持beforeCreat与created两个钩子。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("ul",[e("li",[s._v("react")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("componentDidMount()中能保证你的组件已经正确渲染。\n\n总结下：\n\n1.跟服务器端渲染（同构）有关系，如果在componentWillMount里面获取数据，fetch data会执行两次，一次在服务器端一次在客户端。在componentDidMount中可以解决这个问题。\n\n2.在componentWillMount中fetch data，数据一定在render后才能到达，如果你忘记了设置初始状态，用户体验不好。\n\n3.react16.0以后，componentWillMount可能会被执行多次。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br")])]),e("h2",{attrs:{id:"react-和-vue-对比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-和-vue-对比"}},[s._v("#")]),s._v(" React 和 Vue 对比")]),s._v(" "),e("ul",[e("li",[s._v("相同点：")])]),s._v(" "),e("p",[s._v("1、组件化和虚拟 DOM。")]),s._v(" "),e("p",[s._v("2、都支持 props 父子组件通信。")]),s._v(" "),e("p",[s._v("3、都支持数据驱动")]),s._v(" "),e("p",[s._v("4、都有服务端渲染")]),s._v(" "),e("p",[s._v("5、都有支持 native 的方案，react: react native vue : weex")]),s._v(" "),e("ul",[e("li",[s._v("不同点：")])]),s._v(" "),e("p",[s._v("1、组件写法不一样：react:jsx vue: 模版")]),s._v(" "),e("p",[s._v("2、状态更新。react：调用 this.setState vue: this.xxx")]),s._v(" "),e("p",[s._v("3、虚拟 DOM 不一样。")]),s._v(" "),e("p",[s._v("vue 会跟踪每个组件的依赖关系，不需要重新渲染整个组件树；\nreact 当状态改变时，会引起整个组件树的重新渲染，但是我们可以通过 shouldComponentUpate 来避免不必要的渲染")]),s._v(" "),e("h2",{attrs:{id:"使用-rem-的原理-62-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-rem-的原理-62-5"}},[s._v("#")]),s._v(" 使用 rem 的原理 62.5%")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("rem 的使用")]),s._v(" "),e("p",[s._v("相对长度单位 相对于根元素(html 元素) font-size 计算值的倍数")]),s._v(" "),e("p",[s._v("rem 在桌面浏览器的 1rem = 16px")])]),s._v(" "),e("li",[e("p",[s._v("rem 的 62.5%\n默认 16 62.%即表示 10px 16 * 62.5% = 10")])])]),s._v(" "),e("h2",{attrs:{id:"如何编写高效的-css-选择符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何编写高效的-css-选择符"}},[s._v("#")]),s._v(" 如何编写高效的 css 选择符")]),s._v(" "),e("ul",[e("li",[s._v("css 是从右到左进行匹配的")])]),s._v(" "),e("h2",{attrs:{id:"进程与线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[s._v("#")]),s._v(" 进程与线程")]),s._v(" "),e("ul",[e("li",[s._v("一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程")])]),s._v(" "),e("ul",[e("li",[e("p",[s._v("线程是处理具体任务的，多线程可以并行处理任务。但是线程是不能单独存在的，它是由进程来启动和管理的。")])]),s._v(" "),e("li",[e("p",[s._v("线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。")])]),s._v(" "),e("li",[e("p",[s._v("特点")])])]),s._v(" "),e("ol",[e("li",[e("p",[s._v("进程中的任意一线程执行出错，都会导致整个进程的崩溃。")])]),s._v(" "),e("li",[e("p",[s._v("线程之间共享进程中的数据。")])]),s._v(" "),e("li",[e("p",[s._v("当一个进程关闭之后，操作系统会回收进程所占用的内存。")])])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("  当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("ol",{attrs:{start:"4"}},[e("li",[s._v("进程之间的内容相互隔离。")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("  进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于<b>进程间通信（IPC）</b>的机制了。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h2",{attrs:{id:"javascript-的执行机制、事件循环、宏任务和微任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript-的执行机制、事件循环、宏任务和微任务"}},[s._v("#")]),s._v(" JavaScript 的执行机制、事件循环、宏任务和微任务")]),s._v(" "),e("p",[s._v("(1) JavaScript 的执行机制")]),s._v(" "),e("ol",[e("li",[s._v("所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。")]),s._v(" "),e("li",[s._v('主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。')]),s._v(" "),e("li",[s._v('一旦"执行栈"中的所有同步任务执行完毕，系统就会读取 "任务队列"，如果有执行任务，则进行执行栈开始执行。')]),s._v(" "),e("li",[s._v("主线程不断重复上面的三步，此过程也就是常说的 Event Loop(事件循环)。")])]),s._v(" "),e("p",[s._v("(2) 名词解释")]),s._v(" "),e("ol",[e("li",[s._v("执行栈")])]),s._v(" "),e("p",[s._v("当我们调用一个方法的时候，js 会生成一个与这个方法相对应的执行环境，也叫执行上下文，这个执行环境存在着这个方法的私有作用域、参数、this 对象等等。因为 js 是单线程的，同一时间只能执行一个方法，所以当一系列的方法被依次调用的时候，js 会先解析这些方法，把其中的同步任务按照执行顺序排队到一个地方，这个地方叫做执行栈。")]),s._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[s._v("主线程")])]),s._v(" "),e("p",[s._v("JavaScript 是单线程的，那么这个单线程就成为主线程。而事件循环在主线程执行完执行栈代码后，才执行的。所以主线程代码执行时间过长，会阻塞事件循环的执行。只有当执行栈为空的时候(同步代码执行完毕)，才会执行事件循环来观察有哪些事件回调需要执行，当事件循环检测到任务队列有事件就读取出回调放到执行栈由主线程执行。")]),s._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[s._v("任务队列")])]),s._v(" "),e("p",[s._v("任务队列也有时称叫消息队列、回调队列。")]),s._v(" "),e("p",[s._v("异步操作会将相关回调添加到任务队列中。而不同的异步操作添加到任务队列的时机也不同，如 onclick, setTimeout,ajax 处理的方式都不同，这些异步操作是由浏览器内核的 webcore 来执行的，webcore 包含下图中的 3 种 webAPI，分别是 DOM Binding、network、timer 模块。\nDOM Binding 模块处理一些 DOM 绑定事件，如 onclick 事件触发时，回调函数会立即被 webcore 添加到任务队列中。\nnetwork 模块处理 Ajax 请求，在网络请求返回时，才会将对应的回调函数添加到任务队列中。\ntimer 模块会对 setTimeout 等计时器进行延时处理，当时间到达的时候，才会将回调函数添加到任务队列中。")]),s._v(" "),e("p",[s._v("（3）事件循环\nJavaScript 整体执行过程：\n主线程运行的时候会生成堆（heap）和栈（stack）；")]),s._v(" "),e("p",[s._v("js 从上到下解析方法，将其中的同步任务按照执行顺序排列到执行栈中；")]),s._v(" "),e("p",[s._v("当程序调用外部的 API 时，比如 ajax、setTimeout 等，会将此类异步任务挂起，继续执行执行栈中的任务，等异步任务返回结果后，再按照执行顺序排列到任务队列中；\n主线程先将执行栈中的同步任务清空，然后检查任务队列中是否有任务，如果有，就将第一个事件对应的回调推到执行栈中执行，若在执行过程中遇到异步任务，则继续将这个异步任务排列到任务队列中。\n主线程每次将执行栈清空后，就去任务队列中检查是否有任务，如果有，就每次取出一个推到执行栈中执行，这个过程是循环往复的... ...，这个过程被称为“Event Loop 事件循环”。")]),s._v(" "),e("p",[s._v("（4）宏任务和微任务")]),s._v(" "),e("p",[s._v("异步任务的执行，就涉及到了宏任务和微任务。\n所有的任务在主线程执行，会形成一个执行栈，执行栈会区分出宏任务和微任务，并把任务放在各自的任务队列中。\n宏任务一般包括整体 SCRIPT 代码块，seiTimeout,setInterval。\n微任务：promise 的 then 方法，process,nextTick。\n所有的异步任务都会被分为宏任务和微任务。宏任务队列一次只会存放一个宏任务，当宏任务队列的任务执行完后，会执行所有的微任务。所有微任务执行完后，会进入下一个事件循环。\n宏任务队列会进入下一个宏任务，并执行这个宏任务。\n一个宏任务执行完后，执行所有的微任务，所有的微任务执行完后，再次开始执行下一个进入宏任务队列的宏任务。这个过程就是一次事件循环。\n所有任务的执行就形成整个的事件循环。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("console.log('1');\n  setTimeout(function() {\n      console.log('2');\n      new Promise(function(resolve) {\n      console.log('3');\n      resolve();\n    }).then(function() {\n      console.log('4')\n    })\n  })\n  console.log('5');\n  setTimeout(function() {\n    console.log('6');\n    new Promise(function(resolve) {\n    console.log('7');\n    resolve();\n  }).then(function() {\n    console.log('8')\n  })\n })\nconsole.log('9');\n\n上面代码执行过程：\n\n第一轮事件循环\n\n整体script代码(同步代码)作为第一个宏任务进入主线程，遇到console.log，输出1\n遇到setTimeout,其回调函数被放到宏任务队列中，暂记为setTmineout1\n遇到console.log，输出5\n遇到setTimeout,其回调函数被放到宏任务队列中，暂记为setTmineout2\n遇到console.log，输出9\n一个宏任务执行结束，去微任务队列查找是否有待执行的任务，没有，结束\n第一轮循环结束，输出：1 5 9\n\n第二轮事件循环\n\n从宏任务队列中取出一个任务，即setTmineout1，开始执行\n遇到console.log，输出2\n遇到Promise,创建Promise,输出了3,同时把Promise.then回调函数放到微任务队列\n一个宏任务执行结束，去微任务队列查找是否有待执行的任务, 发现有微任务，全部取出放到执行栈执行\n执行微任务，此时就一个微任务，console.log，输出4\n微任务执行结束\n第二轮循环结束，输出：2 3 4\n\n第三轮事件循环与第二轮一样，输出：6 7 8\n事件循环发现所有任务都已经处理完毕，此时程序执行结束\n全部的输出：1 5 9 2 3 4 6 7 8,可复制代码到chrome浏览器控制台中运行校验结果\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br"),e("span",{staticClass:"line-number"},[s._v("26")]),e("br"),e("span",{staticClass:"line-number"},[s._v("27")]),e("br"),e("span",{staticClass:"line-number"},[s._v("28")]),e("br"),e("span",{staticClass:"line-number"},[s._v("29")]),e("br"),e("span",{staticClass:"line-number"},[s._v("30")]),e("br"),e("span",{staticClass:"line-number"},[s._v("31")]),e("br"),e("span",{staticClass:"line-number"},[s._v("32")]),e("br"),e("span",{staticClass:"line-number"},[s._v("33")]),e("br"),e("span",{staticClass:"line-number"},[s._v("34")]),e("br"),e("span",{staticClass:"line-number"},[s._v("35")]),e("br"),e("span",{staticClass:"line-number"},[s._v("36")]),e("br"),e("span",{staticClass:"line-number"},[s._v("37")]),e("br"),e("span",{staticClass:"line-number"},[s._v("38")]),e("br"),e("span",{staticClass:"line-number"},[s._v("39")]),e("br"),e("span",{staticClass:"line-number"},[s._v("40")]),e("br"),e("span",{staticClass:"line-number"},[s._v("41")]),e("br"),e("span",{staticClass:"line-number"},[s._v("42")]),e("br"),e("span",{staticClass:"line-number"},[s._v("43")]),e("br"),e("span",{staticClass:"line-number"},[s._v("44")]),e("br"),e("span",{staticClass:"line-number"},[s._v("45")]),e("br"),e("span",{staticClass:"line-number"},[s._v("46")]),e("br"),e("span",{staticClass:"line-number"},[s._v("47")]),e("br"),e("span",{staticClass:"line-number"},[s._v("48")]),e("br")])]),e("p",[s._v("常见的一些宏任务和微任务：")]),s._v(" "),e("ul",[e("li",[s._v("macrotask：")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("  setTimeout\n  setInterval\n  setImmediate\n  requestAnimationFrame\n  I/O\n  UI rendering\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])]),e("ul",[e("li",[s._v("microtask:")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("  process.nextTick\n  Promises\n  Object.observe\n  MutationObserver\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("ul",[e("li",[s._v("Promise、Async、Await 都是一种异步解决方案")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("Promise是一个构造函数，调用的时候会生成Promise实例。当Promise的状态改变时会调用then函数中定义的回调函数。我们都知道这个回调函数不会立刻执行，他是一个微任务会被添加到当前任务队列中的末尾，在下一轮任务开始执行之前执行。\nasync/await成对出现，async标记的函数会返回一个Promise对象，可以使用then方法添加回调函数。await后面的语句会同步执行。但 await 下面的语句会被当成微任务添加到当前任务队列的末尾异步执行。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("h2",{attrs:{id:"vue3-为什么要用-proxy-替换-object-defineproperty-？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue3-为什么要用-proxy-替换-object-defineproperty-？"}},[s._v("#")]),s._v(" vue3 为什么要用 proxy 替换 Object.defineproperty ？")]),s._v(" "),e("p",[s._v('1.Vue 3 在设计上选择使用 Proxy 替代 Object.defineProperty 主要是为了提供更好的响应性和性能。​\n2。Object.defineProperty 只能对已经存在的属性进行劫持，无法拦截新增的属性和删除的属性。这就意味着在 Vue 2.x 中，当你添加或删除属性时，需要使用特定的方法(Vue.set 和 Vue.delete)来通知 Vue 响应式系统进行更新。这种限制增加了开发的复杂性。​\n3.Object.defineProperty 的劫持是基于属性级别的，也就是说每个属性都需要被劫持。这对于大规模的对象或数组来说，每次都需要深度递归进行响应劫持，会导致性能下降。因为每个属性都需要添加劫持逻辑，这会增加内存消耗和初始化时间。​ 4.相比之下，Proxy 是 ES6 中引入的元编程特性，可以对整个对象进行拦截和代理。Proxy 提供了更强大和灵活的拦截能力，可以拦截对象的读取、赋值、删除等操作。Vue 3.x 利用 Proxy 的特性，可以更方便地实现响应式系统。​ 5.使用 Proxy 可以解决 Object.defineProperty 的限制问题。它可以直接拦截对象的读取和赋值操作，无需在每个属性上进行劫持。这样就消除了属性级别的劫持开销，提高了初始化性能。另外，Proxy 还可以拦截新增属性和删除属性的操作，使得响应式系统更加完备和自动化。\n6.Vue 3 中使用 Proxy 初始化时只对通过 get 访问到的属性进行响应式处理。这是一种优化策略，也被称为"懒代理"或"懒观察"，它有助于提高性能并减少不必要的代理操作。')])])}),[],!1,null,null,null);e.default=t.exports}}]);