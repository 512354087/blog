(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{663:function(s,e,t){"use strict";t.r(e);var a=t(76),n=Object(a.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"react-性能优化手段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-性能优化手段"}},[s._v("#")]),s._v(" React 性能优化手段")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("1.shouldComponentUpdate\n2.memo\n3.getDerviedStateFromProps 4.使用 Fragment\n5.v-for 使用正确的 key\n6.拆分尽可能小的可复用组件，ErrorBoundary\n7.使用 React.lazy 和 React.Suspense 延迟加载不需要立马使用的组件\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])]),e("h2",{attrs:{id:"错误边界"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#错误边界"}},[s._v("#")]),s._v(" 错误边界")]),s._v(" "),e("p",[s._v("React 部分组件的错误不应该导致整个应用崩溃，为了解决这个问题，React16 引入了错误边界\n使用方法：\nReact 组件在内部定义了 getDerivedStateFromError 或者 componentDidCatch，它就是一个错误边界。getDerviedStateFromError 和 componentDidCatch 的区别是前者展示降级 UI，后者记录具体的错误信息，它只能用于 class 组件")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('import React from "react"\nclass ErrorBoundary extends React.Component{\n  constructor(props){\n    super(props)\n    this.state={\n      hasError:false\n    }\n  }\n  staic getDerivedStateFromError(){\n    return { hasError:true}\n  }\n  componentDidCatch(err,info){\n    console.error(err,info)\n  }\n  render(){\n    if(this.state.hasError){\n      return <div>Oops,err</div>\n    }\n    return this.props.children\n  }\n}\n\n// App.jsx\nimport React from "react"\nimport ErrorBoundary from "./components/ErrorBoundary"\nimport ComponentA from "./components/ComponentA"\nexport class App extends React.Component{\n  render(){\n    return (\n      <ErrorBoundary>\n        <ComponentA></ComponentA>\n      </ErrorBoundary>\n    )\n  }\n}\n\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br"),e("span",{staticClass:"line-number"},[s._v("26")]),e("br"),e("span",{staticClass:"line-number"},[s._v("27")]),e("br"),e("span",{staticClass:"line-number"},[s._v("28")]),e("br"),e("span",{staticClass:"line-number"},[s._v("29")]),e("br"),e("span",{staticClass:"line-number"},[s._v("30")]),e("br"),e("span",{staticClass:"line-number"},[s._v("31")]),e("br"),e("span",{staticClass:"line-number"},[s._v("32")]),e("br"),e("span",{staticClass:"line-number"},[s._v("33")]),e("br"),e("span",{staticClass:"line-number"},[s._v("34")]),e("br"),e("span",{staticClass:"line-number"},[s._v("35")]),e("br"),e("span",{staticClass:"line-number"},[s._v("36")]),e("br")])]),e("p",[s._v("错误边界无法捕获自身的错误，也无法捕获事件处理、异步代码(setTimeout、requestAnimationFrame)、服务端渲染的错误")]),s._v(" "),e("h2",{attrs:{id:"portal"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#portal"}},[s._v("#")]),s._v(" Portal")]),s._v(" "),e("p",[s._v("Portal 提供了让子组件渲染在除了父组件之外的 DOM 节点的方式,它接收两个参数，第一个是需要渲染的 React 元素，第二个是渲染的地方(DOM 元素)")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("ReactDOM.createPortal(child,container)\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h2",{attrs:{id:"fragment"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fragment"}},[s._v("#")]),s._v(" Fragment (<></>)")]),s._v(" "),e("p",[s._v("Fragment 提供了一种将子列表分组又不产生额外 DOM 节点的方法")]),s._v(" "),e("h2",{attrs:{id:"context"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[s._v("#")]),s._v(" Context")]),s._v(" "),e("p",[s._v("常规的组件数据传递是使用 props，当一个嵌套组件向另一个嵌套组件传递数据时，props 会被传递很多层，很多不需要用到 props 的组件也引入了数据，会造成数据来源不清晰，多余的变量定义等问题，Context 提供了一种跨层级组件数据传递的方法")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("const ThemeContext = React.createContext('light')\nclass App extends React.Component {\n  render(){\n    return(\n      <ThemeContext.Provider value=\"dark\">\n        <ToolBar/>\n      </ThemeContext>\n    )\n  }\n}\n\nfunction ToolBar(){\n  return <div>\n   <ThemeButton/>\n  </div>\n}\n\nclass ThemeButton extends React.Component {\n  static contextType = ThemeContext\n  render(){\n    return <Button theme={this.context}></Button>\n  }\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br")])]),e("h2",{attrs:{id:"suspense"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#suspense"}},[s._v("#")]),s._v(" Suspense")]),s._v(" "),e("p",[s._v("Suspense 使组件允许在某些操作结束后再进行渲染，比如接口请求,一般与 React.lazy 一起使用")]),s._v(" "),e("h2",{attrs:{id:"数据传递"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据传递"}},[s._v("#")]),s._v(" 数据传递")]),s._v(" "),e("ul",[e("li",[s._v("props")]),s._v(" "),e("li",[s._v("useContext")]),s._v(" "),e("li",[s._v("回调")]),s._v(" "),e("li",[s._v("forwardRef useImperativeHandle")]),s._v(" "),e("li",[s._v("Redux")]),s._v(" "),e("li",[s._v("hoc")])]),s._v(" "),e("h2",{attrs:{id:"setstate-是同步还是异步的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#setstate-是同步还是异步的"}},[s._v("#")]),s._v(" SetState 是同步还是异步的")]),s._v(" "),e("p",[s._v("setState 是一个异步方法，但是在 setTimeout/setInterval 等定时器里逃脱了 React 对它的掌控，变成了同步方法\n实现机制类似于 vue 的$nextTick 和浏览器的事件循环机制，每个 setState 都会被 react 加入到任务队列，多次对同一个 state 使用 setState 只会返回最后一次的结果，因为它不是立刻就更新，而是先放在队列中，等时机成熟在执行批量更新。React18 以后，使用了 createRoot api 后，所有 setState 都是异步批量执行的")]),s._v(" "),e("h2",{attrs:{id:"fiber-架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fiber-架构"}},[s._v("#")]),s._v(" fiber 架构")]),s._v(" "),e("ul",[e("li",[s._v("什么是 fiber，fiber 解决了什么问题")])]),s._v(" "),e("p",[s._v("在 React16 以前，React 更新是通过树的深度优先遍历完成的，遍历是不能中断的，当树的层级深就会产生栈的层级过深，页面渲染速度变慢的问题，为了解决这个问题引入了 fiber，React fiber 就是虚拟 DOM，它是一个链表结构，返回了 return、children、siblings，分别代表父 fiber，子 fiber 和兄弟 fiber，随时可中断")]),s._v(" "),e("h2",{attrs:{id:"react-合成事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-合成事件"}},[s._v("#")]),s._v(" react 合成事件")]),s._v(" "),e("p",[s._v("react 绑定有自己的一套事件机制，就是合成事件")]),s._v(" "),e("p",[s._v("如上：onClick 事件是绑定在 DOM 上面的吗？ 答案：不是。\n• 它是通过事件冒泡机制冒泡到 document 上的，然后 react 将事件封装给正式的函数(中间层 SyntheticEvent)进行运行和处理的\n• 当事件触发的时候，对使用统一的分发函数 dispatchEvent 将指定函数执行。\n注册和分发的过程。这里面至少要说出事件注册都是在元素的最顶层 document 节点上。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('<div className="testDom" onClick={this.testDomClick()}><div>\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h2",{attrs:{id:"列出-redux-的组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#列出-redux-的组件"}},[s._v("#")]),s._v(" 列出 Redux 的组件")]),s._v(" "),e("p",[s._v("Action – 这是一个用来描述发生了什么事情的对象。\nReducer – 这是一个确定状态将如何变化的地方。\nStore – 整个程序的状态/对象树保存在 Store 中。\nView – 只显示 Store 提供的数据。")])])}),[],!1,null,null,null);e.default=n.exports}}]);