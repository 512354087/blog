(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{661:function(e,t,s){"use strict";s.r(t);var a=s(76),n=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"vue-3-相比-vue-2-有哪些主要改进？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-相比-vue-2-有哪些主要改进？"}},[e._v("#")]),e._v(" Vue 3 相比 Vue 2 有哪些主要改进？")]),e._v(" "),t("p",[e._v("使用了 Composition API，提高了代码逻辑的可复用性。\n引入了 Fragment，允许组件有多个根节点。\n更好的 TypeScript 支持。\n使用了更小的包体积和更高效的运行时性能。\n提供了 Suspense 组件，用于处理异步组件的加载状态。\nTeleport 组件允许将子组件渲染到 DOM 中的任何位置。")]),e._v(" "),t("h2",{attrs:{id:"vue2-和-vue3-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue2-和-vue3-的区别"}},[e._v("#")]),e._v(" vue2 和 vue3 的区别")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("vue2的实现方式是通过Object.defineProperty来重新定义getter，setter方法实现的。\n新版的Vue3使用ES6的Proxy方式来解决这个问题。之前遇到的两个问题就简单的多了。首先Proxy是支持数组的也就是数组是不需要做特别的代码的。对于深层监听也不不必要使用递归的方式解决。当get是判断值为对象时将对象做响应式处理返回就可以了。大家想想这个并不不是发生在初始化的时候而是设置值得时候当然性能上得到很大的提升\n\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("h2",{attrs:{id:"react-和-vue-对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-和-vue-对比"}},[e._v("#")]),e._v(" React 和 Vue 对比")]),e._v(" "),t("ul",[t("li",[e._v("相同点：")])]),e._v(" "),t("p",[e._v("1、组件化和虚拟 DOM。")]),e._v(" "),t("p",[e._v("2、都支持 props 父子组件通信。")]),e._v(" "),t("p",[e._v("3、都支持数据驱动")]),e._v(" "),t("p",[e._v("4、都有服务端渲染")]),e._v(" "),t("p",[e._v("5、都有支持 native 的方案，react: react native vue : weex")]),e._v(" "),t("ul",[t("li",[e._v("不同点：")])]),e._v(" "),t("p",[e._v("1、组件写法不一样：react:jsx vue: 模版")]),e._v(" "),t("p",[e._v("2、状态更新。react：调用 this.setState vue: this.xxx")]),e._v(" "),t("p",[e._v("3、虚拟 DOM 不一样。")]),e._v(" "),t("p",[e._v("vue 会跟踪每个组件的依赖关系，不需要重新渲染整个组件树；\nreact 当状态改变时，会引起整个组件树的重新渲染，但是我们可以通过 shouldComponentUpate 来避免不必要的渲染")]),e._v(" "),t("h2",{attrs:{id:"vue3-为什么要用-proxy-替换-object-defineproperty-？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue3-为什么要用-proxy-替换-object-defineproperty-？"}},[e._v("#")]),e._v(" vue3 为什么要用 proxy 替换 Object.defineproperty ？")]),e._v(" "),t("p",[e._v('1.Vue 3 在设计上选择使用 Proxy 替代 Object.defineProperty 主要是为了提供更好的响应性和性能。​\n2。Object.defineProperty 只能对已经存在的属性进行劫持，无法拦截新增的属性和删除的属性。这就意味着在 Vue 2.x 中，当你添加或删除属性时，需要使用特定的方法(Vue.set 和 Vue.delete)来通知 Vue 响应式系统进行更新。这种限制增加了开发的复杂性。​\n3.Object.defineProperty 的劫持是基于属性级别的，也就是说每个属性都需要被劫持。这对于大规模的对象或数组来说，每次都需要深度递归进行响应劫持，会导致性能下降。因为每个属性都需要添加劫持逻辑，这会增加内存消耗和初始化时间。​ 4.相比之下，Proxy 是 ES6 中引入的元编程特性，可以对整个对象进行拦截和代理。Proxy 提供了更强大和灵活的拦截能力，可以拦截对象的读取、赋值、删除等操作。Vue 3.x 利用 Proxy 的特性，可以更方便地实现响应式系统。​ 5.使用 Proxy 可以解决 Object.defineProperty 的限制问题。它可以直接拦截对象的读取和赋值操作，无需在每个属性上进行劫持。这样就消除了属性级别的劫持开销，提高了初始化性能。另外，Proxy 还可以拦截新增属性和删除属性的操作，使得响应式系统更加完备和自动化。\n6.Vue 3 中使用 Proxy 初始化时只对通过 get 访问到的属性进行响应式处理。这是一种优化策略，也被称为"懒代理"或"懒观察"，它有助于提高性能并减少不必要的代理操作。')]),e._v(" "),t("h2",{attrs:{id:"请解释-vue-3-的-composition-api-是什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#请解释-vue-3-的-composition-api-是什么？"}},[e._v("#")]),e._v(" 请解释 Vue 3 的 Composition API 是什么？")]),e._v(" "),t("p",[e._v("Composition API 是一组新的、基于函数的 API，它允许你以更灵活和可复用的方式组织组件逻辑。它主要包括 ref、reactive、computed、watch、setup 等函数和钩子。")]),e._v(" "),t("h2",{attrs:{id:"setup-函数在-vue-3-中起什么作用？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#setup-函数在-vue-3-中起什么作用？"}},[e._v("#")]),e._v(" setup()函数在 Vue 3 中起什么作用？")]),e._v(" "),t("p",[e._v("setup() 是 Vue 3 组件选项 API 中的一个新选项。它是 Composition API 的入口点，在组件被创建之前执行，用于初始化状态、计算属性和方法，并返回在模板中使用的响应式引用")]),e._v(" "),t("h2",{attrs:{id:"请解释-ref-和-reactive-的区别？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#请解释-ref-和-reactive-的区别？"}},[e._v("#")]),e._v(" 请解释 ref 和 reactive 的区别？")]),e._v(" "),t("p",[e._v("ref 用于创建简单的响应式引用，通常用于基本数据类型。 reactive 用于创建响应式对象，通常用于复杂数据类型如数组和对象。")]),e._v(" "),t("h2",{attrs:{id:"vue-3-中的-watch-和-watcheffect-有何不同？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-中的-watch-和-watcheffect-有何不同？"}},[e._v("#")]),e._v(" Vue 3 中的 watch 和 watchEffect 有何不同？")]),e._v(" "),t("p",[e._v("watch 允许你监听特定的响应式引用或计算属性，并在它们改变时执行回调函数。 watchEffect 会立即执行一个函数，并自动追踪其依赖的响应式引用，当依赖改变时重新执行。")]),e._v(" "),t("h2",{attrs:{id:"vue-3-中的-suspense-组件是如何工作的？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-中的-suspense-组件是如何工作的？"}},[e._v("#")]),e._v(" Vue 3 中的 Suspense 组件是如何工作的？")]),e._v(" "),t("p",[e._v("Suspense 组件允许你指定一个加载中的状态（fallback）和一个加载失败的状态（fallback slot），用于处理异步组件的加载状态。当异步组件加载时，会先显示加载中的状态；加载完成后，会显示异步组件；如果加载失败，会显示加载失败的状态。")]),e._v(" "),t("h2",{attrs:{id:"vue-3-中的-teleport-组件有什么作用？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-中的-teleport-组件有什么作用？"}},[e._v("#")]),e._v(" Vue 3 中的 Teleport 组件有什么作用？")]),e._v(" "),t("p",[e._v("Teleport 组件允许你将子组件渲染到 DOM 树中的任何位置，而不仅仅是其父组件的模板内。这在处理模态框、下拉菜单等需要渲染到特定位置的组件时非常有用。")]),e._v(" "),t("h2",{attrs:{id:"vue-3-如何优化性能？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-如何优化性能？"}},[e._v("#")]),e._v(" Vue 3 如何优化性能？")]),e._v(" "),t("p",[e._v("使用 v-show 代替 v-if 来频繁切换元素，因为 v-show 只是切换元素的 CSS 属性。 使用 key 来优化列表渲染的性能。 使用 computed 和 watch 来减少不必要的计算和渲染。 使用 v-memo 来缓存组件的渲染结果。")]),e._v(" "),t("h2",{attrs:{id:"vue-3-的-provide-和-inject-是如何工作的？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-的-provide-和-inject-是如何工作的？"}},[e._v("#")]),e._v(" Vue 3 的 provide 和 inject 是如何工作的？")]),e._v(" "),t("p",[e._v("provide 和 inject 允许你在祖先组件和后代组件之间传递数据，而不需要通过 props 和 events 进行逐层传递。provide 在祖先组件中定义要传递的数据，inject 在后代组件中接收数据。")]),e._v(" "),t("h2",{attrs:{id:"vue-3-如何处理组件的异步加载？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-如何处理组件的异步加载？"}},[e._v("#")]),e._v(" Vue 3 如何处理组件的异步加载？")]),e._v(" "),t("p",[e._v("Vue 3 使用 defineAsyncComponent 函数来定义异步组件。异步组件允许你延迟加载组件，直到需要时才加载，从而优化性能。")]),e._v(" "),t("h2",{attrs:{id:"vue-3-中的响应式系统是如何工作的？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-中的响应式系统是如何工作的？"}},[e._v("#")]),e._v(" Vue 3 中的响应式系统是如何工作的？")]),e._v(" "),t("p",[e._v("Vue 3 的响应式系统通过 ES6 的 Proxy 对象来实现。当使用 reactive 或 ref 函数时，Vue 会创建一个 Proxy 对象来包裹原始数据。这个 Proxy 对象会拦截对原始数据的访问和修改，从而可以追踪到数据的变化。当数据发生变化时，Vue 会触发相应的依赖更新，重新渲染视图。")]),e._v(" "),t("h2",{attrs:{id:"vue-3-中的自定义指令是如何定义的？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-中的自定义指令是如何定义的？"}},[e._v("#")]),e._v(" Vue 3 中的自定义指令是如何定义的？")]),e._v(" "),t("p",[e._v("Vue 3 中的自定义指令可以使用 app.directive()方法或组件的 directives 选项来定义。自定义指令包含一些钩子函数，如 bind、inserted、update、componentUpdated 和 unbind，这些钩子函数会在指令的不同生命周期阶段被调用。")]),e._v(" "),t("h2",{attrs:{id:"vue-3-的插槽（slots）和-vue-2-有何不同？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-的插槽（slots）和-vue-2-有何不同？"}},[e._v("#")]),e._v(" Vue 3 的插槽（Slots）和 Vue 2 有何不同？")]),e._v(" "),t("p",[e._v("Vue 3 的插槽（Slots）与 Vue 2 相比有一些改进和变化。首先，Vue 3 支持具名插槽和默认插槽的混合使用，这使得插槽的使用更加灵活。其次，Vue 3 引入了作用域插槽（Scoped Slots），允许你在插槽中访问子组件的数据和方法。此外，Vue 3 还改进了插槽的渲染和更新性能。")]),e._v(" "),t("h2",{attrs:{id:"vue-3-的事件修饰符有哪些？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-的事件修饰符有哪些？"}},[e._v("#")]),e._v(" Vue 3 的事件修饰符有哪些？")]),e._v(" "),t("p",[e._v("Vue 3 的事件修饰符与 Vue 2 保持一致，主要包括：")]),e._v(" "),t("p",[e._v(".stop：阻止事件冒泡\n.prevent：阻止默认事件行为\n.capture：使用事件捕获模式\n.self：只有当事件在元素本身（而不是子元素）触发时触发回调\n.once：事件只触发一次\n.left：只当鼠标左键被点击时触发\n.right：只当鼠标右键被点击时触发\n.middle：只当鼠标中键被点击时触发\n.passive：以 { passive: true } 模式调用 eventListener")]),e._v(" "),t("h2",{attrs:{id:"vue-3-中的-fragment-是什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-中的-fragment-是什么？"}},[e._v("#")]),e._v(" Vue 3 中的 Fragment 是什么？")]),e._v(" "),t("p",[e._v("在 Vue 3 中，Fragment 允许组件有多个根节点。在 Vue 2 中，组件只能有一个根节点，但在 Vue 3 中，组件可以有多个根节点，这使得组件的结构更加灵活。Fragment 在渲染时会被视为一个虚拟节点，并不会实际创建额外的 DOM 元素。")]),e._v(" "),t("h2",{attrs:{id:"composition-api-和-react-hook-很像-它们有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#composition-api-和-react-hook-很像-它们有什么区别"}},[e._v("#")]),e._v(" Composition API 和 React Hook 很像, 它们有什么区别?")]),e._v(" "),t("p",[e._v("是很像, Composition API 诞生之初就借鉴了 React Hook, 同时避免了 reack Hook 的短板限制:(吹爆 vue3 好吗)")]),e._v(" "),t("ul",[t("li",[e._v("reack Hook 的限制:")])]),e._v(" "),t("p",[e._v("不能在循环中、条件、调用嵌套函数 Hook\n你必须确保它总是在你这边 React Top level 调用函数 Hook\nuseEffect、useMemo 依赖关系必须手动确定")]),e._v(" "),t("ul",[t("li",[e._v("Composition API 相比于 React Hook 优点:")])]),e._v(" "),t("p",[e._v("Compositon API 不必担心调用的顺序，它也可以在循环中、条件、在嵌套函数中使用\nReact Hook 每次重新渲染时，都需要调用 Hook, 而 vue3 在 setup 函数中，一个组件实例只调用一次 setup，性能相对 react hook 较高\nvue 响应式系统自动实现依赖关系收集，而且组件的性能优化是由 Vue 内部完成的，而 React Hook 的依赖关系需要手动传递，并且依赖关系的顺序必须得到保证，让路 useEffect、useMemo 等等，否则组件性能会因为依赖关系不正确而下降。")]),e._v(" "),t("h2",{attrs:{id:"vuex-和-pinia"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vuex-和-pinia"}},[e._v("#")]),e._v(" vuex 和 pinia")]),e._v(" "),t("p",[e._v("Vuex：Vuex 的设计基于集中式状态管理的概念，所有组件都共享同一个 store 实例，因此需要在 main.js 中全局注册这个 store。\nPinia：Pinia 的设计更侧重于组件内部的状态管理，它允许你创建多个 store 并在需要的地方使用。虽然在 main.js 中也需要注册 Pinia，但这更多是为了整合 Pinia 到 Vue 应用中，而不是为了提供全局的 store 实例。Pinia 的 store 实例通常是通过组合式 API 在组件内部定义和使用的。")]),e._v(" "),t("ul",[t("li",[e._v("vuex")])]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("state\ngetters\nmutations\nAction\nModule\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br")])]),t("h2",{attrs:{id:"vue-中常用的-define-函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-中常用的-define-函数"}},[e._v("#")]),e._v(" vue 中常用的 define 函数")]),e._v(" "),t("ul",[t("li",[e._v("defineAsyncComponent\nvue3 还支持使用 defineAsyncComponent 函数来异步加载指令 插件 模版")])]),e._v(" "),t("div",{staticClass:"language-ts line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-ts"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" HelloWorld "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("defineComponent")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("import")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"../../HelloWord.vue"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 参数")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" HelloWorld "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("defineComponent")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("loader")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("import")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"../../HelloWord.vue"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  loadingComponent"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" LoadingComponent"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 在加载时显示")]),e._v("\n  erroerComponent"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" ErrorComponent "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/** 错误时显示 */")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  delay"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("200")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/** 延迟显示 */")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  timeout"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("3000")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/** 超时时间 */")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br")])]),t("ul",[t("li",[t("p",[e._v("defineProps\ndefineProps 用于在"),t("script",{attrs:{setup:""}})])])])])}),[],!1,null,null,null);t.default=n.exports}}]);