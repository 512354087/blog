(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{680:function(t,a,_){"use strict";_.r(a);var v=_(76),s=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"一、http报文结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、http报文结构"}},[t._v("#")]),t._v(" 一、HTTP报文结构")]),t._v(" "),a("p",[t._v("HTTP报文结构：\n"),a("code",[t._v("起始行+头部+空行+实体")])]),t._v(" "),a("p",[t._v("起始行分为"),a("strong",[t._v("请求行")]),t._v("和"),a("strong",[t._v("响应行")]),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"请求行："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请求行："}},[t._v("#")]),t._v(" 请求行：")]),t._v(" "),a("p",[a("code",[t._v("GET /home HTTP/1.1")])]),t._v(" "),a("h3",{attrs:{id:"响应行："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应行："}},[t._v("#")]),t._v(" 响应行：")]),t._v(" "),a("p",[a("code",[t._v("HTTP/1.1 200 OK")])]),t._v(" "),a("h3",{attrs:{id:"头部"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#头部"}},[t._v("#")]),t._v(" 头部")]),t._v(" "),a("ol",[a("li",[t._v("字段名不区分大小写")]),t._v(" "),a("li",[t._v("不允许出现空格")]),t._v(" "),a("li",[t._v("字段名后面必须紧跟着"),a("code",[t._v("：")])])]),t._v(" "),a("p",[t._v("空行用来区分头部和实体")]),t._v(" "),a("h2",{attrs:{id:"二、http请求方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、http请求方法"}},[t._v("#")]),t._v(" 二、HTTP请求方法")]),t._v(" "),a("ul",[a("li",[t._v("GET   获取资源")]),t._v(" "),a("li",[t._v("POST  更新资源")]),t._v(" "),a("li",[t._v("HEAD  获取资源的元信息，用于获取报头")]),t._v(" "),a("li",[t._v("PUT   修改数据")]),t._v(" "),a("li",[t._v("OPTIONS 列出可对资源实行的请求方法")]),t._v(" "),a("li",[t._v("DELETE  删除资源")]),t._v(" "),a("li",[t._v("CONNECT 建立连接隧道，用于代理服务器")]),t._v(" "),a("li",[t._v("TRACE 追踪请求")])]),t._v(" "),a("p",[t._v("GET和POST的区别：")]),t._v(" "),a("ol",[a("li",[t._v("GET可被浏览器缓存，会留下历史记录")]),t._v(" "),a("li",[t._v("GET只能进行URL编码，只能接收ASCII字符，POST不受限制")]),t._v(" "),a("li",[t._v("GET传递数据大小一般被浏览器限制大小，POST没有限制")]),t._v(" "),a("li",[t._v("从TCP看，GET会把请求报文一次性发出去，POST会分为两个TCP包，首先发header部分，如果服务器响应100，然后发送body部分。")])]),t._v(" "),a("h2",{attrs:{id:"三、uri"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、uri"}},[t._v("#")]),t._v(" 三、URI")]),t._v(" "),a("p",[t._v("URI： 统一资源标识符，区分互联网上不同的资源")]),t._v(" "),a("p",[t._v("URI = URN + URL")]),t._v(" "),a("p",[t._v("组成部分：")]),t._v(" "),a("ol",[a("li",[t._v("scheme：协议名（http/https/file）+ "),a("code",[t._v("://")])]),t._v(" "),a("li",[t._v("user:passwd@： 登录主机时的用户信息，不安全，不常用")]),t._v(" "),a("li",[t._v("host:port： 主机和端口号")]),t._v(" "),a("li",[t._v("path： 路径")]),t._v(" "),a("li",[t._v("query： 查询参数")]),t._v(" "),a("li",[t._v("fragment： 锚点")])]),t._v(" "),a("p",[t._v("URI编码：")]),t._v(" "),a("p",[t._v("ASCII（128个）之外的字符不支持，将所有非 ASCII 码字符和界定符转为"),a("strong",[t._v("十六进制字节值")]),t._v("，然后在前面加个"),a("code",[t._v("%")])]),t._v(" "),a("h2",{attrs:{id:"四、http状态码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、http状态码"}},[t._v("#")]),t._v(" 四、HTTP状态码")]),t._v(" "),a("ul",[a("li",[t._v("1xx： 目前处于协议的中间状态，还需要后续操作")]),t._v(" "),a("li",[t._v("2xx： 成功状态")]),t._v(" "),a("li",[t._v("3xx： 重定向，资源位置发生变动，需要重新请求")]),t._v(" "),a("li",[t._v("4xx： 请求报文有错误")]),t._v(" "),a("li",[t._v("5xx： 服务端发生错误")])]),t._v(" "),a("p",[t._v("常见相关状态码：")]),t._v(" "),a("ul",[a("li",[t._v("100: 继续。客户端应当继续发送请求。")]),t._v(" "),a("li",[t._v("101: "),a("code",[t._v("HTTP")]),t._v("升级为"),a("code",[t._v("WebSocket")]),t._v("时，如果服务器同意变更，会发送101")]),t._v(" "),a("li",[t._v("200: 成功状态码，响应体中有数据")]),t._v(" "),a("li",[t._v("204: "),a("code",[t._v("No Conent")]),t._v("，响应体中没有数据")]),t._v(" "),a("li",[t._v("206: "),a("code",[t._v("Partial Content")]),t._v("，部分内容，HTTP分块下载和断点续传，响应头字段也会带上"),a("strong",[t._v("Content-Range")])]),t._v(" "),a("li",[t._v("301: 永久重定向。浏览器默认会做缓存优化，第二次访问的时候自动访问那个重定向的新地址。")]),t._v(" "),a("li",[t._v("302: 临时重定向。浏览器不会做缓存优化。")]),t._v(" "),a("li",[t._v("304: "),a("code",[t._v("Not Modified")]),t._v("，"),a("strong",[t._v("协商缓存")]),t._v("命中")]),t._v(" "),a("li",[t._v("400: "),a("code",[t._v("Bad Request")]),t._v("，请求错误")]),t._v(" "),a("li",[t._v("401: "),a("code",[t._v("unauthorized")]),t._v("，未鉴权，发送的请求需要有通过HTTP认证的认证信息")]),t._v(" "),a("li",[t._v("403: "),a("code",[t._v("Forbidden")]),t._v("，请求被拒绝，服务器禁止访问")]),t._v(" "),a("li",[t._v("404: 资源找不到")]),t._v(" "),a("li",[t._v("405: "),a("code",[t._v("Method Not Allowed")]),t._v("，请求方法不被允许")]),t._v(" "),a("li",[t._v("406: "),a("code",[t._v("Not Acceptable")]),t._v("，资源无法满足客户端条件")]),t._v(" "),a("li",[t._v("413: "),a("code",[t._v("Request Entity Too Large")]),t._v("，请求体的体积过大")]),t._v(" "),a("li",[t._v("414: "),a("code",[t._v("Request-URL Too Large")]),t._v("，请求行里的URL太大")]),t._v(" "),a("li",[t._v("429: "),a("code",[t._v("Too Many Request")]),t._v("，客户端发送的请求过多")]),t._v(" "),a("li",[t._v("431: "),a("code",[t._v("Request Header Fields Too Large")]),t._v("，请求头的字段内容过大")]),t._v(" "),a("li",[t._v("500: 服务器出错")]),t._v(" "),a("li",[t._v("501: 客户端的请求目前还不支持")]),t._v(" "),a("li",[t._v("502: 服务器本身正常，但访问的时候出错")]),t._v(" "),a("li",[t._v("503: 服务器忙，暂时无法响应")])]),t._v(" "),a("h2",{attrs:{id:"五、http特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、http特点"}},[t._v("#")]),t._v(" 五、HTTP特点")]),t._v(" "),a("p",[t._v("HTTP特点：")]),t._v(" "),a("ol",[a("li",[t._v("灵活可扩展。语义上的自由，传输形式多样式。")]),t._v(" "),a("li",[t._v("可靠传输。基于TCP")]),t._v(" "),a("li",[t._v("请求-应答。一发一收，有来有回。")]),t._v(" "),a("li",[t._v("无状态。状态是指通信过程的上下文信息，每次http请求都是独立的、无关的。")])]),t._v(" "),a("p",[t._v("HTTP缺点：")]),t._v(" "),a("ul",[a("li",[t._v("明文传输。报文（主要指头部）不是用二进制，而是文本，容易被截取")]),t._v(" "),a("li",[t._v("队头阻塞问题。HTTP开启长连接时，"),a("strong",[t._v("共用一个TCP")]),t._v("，同一时刻只能处理一个请求，当前请求耗时过长的情况下，其它请求只能处于阻塞状态，这就是"),a("strong",[t._v("队头阻塞")]),t._v("问题。")])]),t._v(" "),a("h2",{attrs:{id:"六、accept字段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、accept字段"}},[t._v("#")]),t._v(" 六、Accept字段")]),t._v(" "),a("p",[t._v("Accept分为四个部分：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("数据格式")])]),t._v(" "),a("li",[a("strong",[t._v("压缩方式")])]),t._v(" "),a("li",[a("strong",[t._v("支持语言")])]),t._v(" "),a("li",[a("strong",[t._v("字符集")])])]),t._v(" "),a("h3",{attrs:{id:"数据格式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据格式"}},[t._v("#")]),t._v(" 数据格式")]),t._v(" "),a("p",[t._v("字段为"),a("strong",[t._v("Accept")]),t._v("和"),a("strong",[t._v("Content-Type")])]),t._v(" "),a("p",[t._v("数据格式主要有四大类：")]),t._v(" "),a("ul",[a("li",[t._v("text： text/html、text/plain、text/css...")]),t._v(" "),a("li",[t._v("image： image/gif、image/jpeg、image/png...")]),t._v(" "),a("li",[t._v("audio/vedio： audio/mpeg、vedio/mp4...")]),t._v(" "),a("li",[t._v("application： application/json、application/javascript、application/pdf...")])]),t._v(" "),a("h3",{attrs:{id:"压缩方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#压缩方式"}},[t._v("#")]),t._v(" 压缩方式")]),t._v(" "),a("p",[t._v("字段为"),a("strong",[t._v("Accept-Encoding")]),t._v("和"),a("strong",[t._v("Content-Encoding")])]),t._v(" "),a("ul",[a("li",[t._v("gzip")]),t._v(" "),a("li",[t._v("deflate")]),t._v(" "),a("li",[t._v("br  //一种专门为 HTTP 发明的压缩算法")])]),t._v(" "),a("h3",{attrs:{id:"支持语言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#支持语言"}},[t._v("#")]),t._v(" 支持语言")]),t._v(" "),a("p",[a("strong",[t._v("Accept-Language")]),t._v("和"),a("strong",[t._v("Content-Language")])]),t._v(" "),a("h3",{attrs:{id:"字符集"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符集"}},[t._v("#")]),t._v(" 字符集")]),t._v(" "),a("p",[a("strong",[t._v("Accept-Charset")]),t._v(",接收端放在了"),a("strong",[t._v("Content-Type")]),t._v("中")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 发送端\nContent-Type: text/html; charset=utf-8\n// 接收端\nAccept-Charset: charset=utf-8\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("h2",{attrs:{id:"七、定长、不定长数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、定长、不定长数据"}},[t._v("#")]),t._v(" 七、定长、不定长数据")]),t._v(" "),a("h3",{attrs:{id:"定长"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定长"}},[t._v("#")]),t._v(" 定长")]),t._v(" "),a("p",[t._v("发送端"),a("strong",[t._v("Content-Length")]),t._v("，用来指明包的长度")]),t._v(" "),a("h3",{attrs:{id:"不定长"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不定长"}},[t._v("#")]),t._v(" 不定长")]),t._v(" "),a("p",[t._v("头部字段：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Transfer-Encoding: chunked\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("表示分块传输。")]),t._v(" "),a("ul",[a("li",[t._v("Content-Length会被忽略")]),t._v(" "),a("li",[t._v("基于长连接持续推送动态内容")])]),t._v(" "),a("p",[a("code",[t._v("Connection: keep-alive")]),t._v("，TCP一直会保持连接。")]),t._v(" "),a("h2",{attrs:{id:"八、http大文件的传输"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#八、http大文件的传输"}},[t._v("#")]),t._v(" 八、HTTP大文件的传输")]),t._v(" "),a("p",[t._v("采取"),a("strong",[t._v("范围请求")]),t._v("的解决大文件传输")]),t._v(" "),a("h3",{attrs:{id:"服务端支持"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务端支持"}},[t._v("#")]),t._v(" 服务端支持")]),t._v(" "),a("p",[t._v("首先，服务器需要支持"),a("strong",[t._v("范围请求")]),t._v("，必须加上响应头：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Accept-Ranges: bytes  //支持范围请求\nAccept-Ranges: none   //不支持范围请求\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("h3",{attrs:{id:"客户端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#客户端"}},[t._v("#")]),t._v(" 客户端")]),t._v(" "),a("p",[t._v("对于客户端，需要指定请求哪一部分，通过"),a("strong",[t._v("Range")]),t._v("字段确定请求范围，格式为"),a("strong",[t._v("bytes=x-y")]),t._v("。")]),t._v(" "),a("p",[t._v("服务器收到请求之后。首先验证范围是否合法，如果越界则返回"),a("strong",[t._v("416")]),t._v("，否则读取相应片段并返回"),a("strong",[t._v("206")]),t._v("。")]),t._v(" "),a("p",[t._v("同时，服务器响应需要添加"),a("strong",[t._v("Content-Range")]),t._v("字段。")]),t._v(" "),a("p",[t._v("具体分为单段请求和多段请求：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 单段数据\nRange: bytes=0-9\n// 多段数据\nRange: bytes=0-9, 30-39\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("h3",{attrs:{id:"单段请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单段请求"}},[t._v("#")]),t._v(" 单段请求")]),t._v(" "),a("p",[t._v("对于单段请求，返回响应：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("HTTP/1.1 206 Partial Content\nContent-Length: 10\nAccept-Ranges: bytes\nContent-Range: bytes 0-9/100\n\ni am xxxxx\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[a("strong",[t._v("Content-Range")]),t._v("指定请求的大小和资源总大小")]),t._v(" "),a("h3",{attrs:{id:"多段请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多段请求"}},[t._v("#")]),t._v(" 多段请求")]),t._v(" "),a("p",[t._v("多段请求的响应：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("HTTP/1.1 206 Partial Content\nContent-Type: multipart/byteranges; boundary=00000010101\nContent-Length: 189\nConnection: keep-alive\nAccept-Ranges: bytes\n\n\n--00000010101\nContent-Type: text/plain\nContent-Range: bytes 0-9/96\n\ni am xxxxx\n--00000010101\nContent-Type: text/plain\nContent-Range: bytes 20-29/96\n\neex jspy e\n--00000010101--\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br"),a("span",{staticClass:"line-number"},[t._v("17")]),a("br"),a("span",{staticClass:"line-number"},[t._v("18")]),a("br")])]),a("p",[a("code",[t._v("Content-Type: multipart/byteranges;boundary=00000010101")]),t._v(" 表示：")]),t._v(" "),a("ol",[a("li",[t._v("请求一定是多段请求")]),t._v(" "),a("li",[t._v("响应体中的分隔符是 00000010101")])]),t._v(" "),a("p",[t._v("在响应体中各段数据之间会由这里指定的"),a("strong",[t._v("分隔符")]),t._v("分开，而且在最后的分隔末尾添上--表示结束。")]),t._v(" "),a("h2",{attrs:{id:"九、http处理表单数据的提交"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#九、http处理表单数据的提交"}},[t._v("#")]),t._v(" 九、HTTP处理表单数据的提交")]),t._v(" "),a("p",[t._v("两种"),a("strong",[t._v("Content-Type")]),t._v("值：")]),t._v(" "),a("ul",[a("li",[t._v("application/x-www-form-urlencoded")]),t._v(" "),a("li",[t._v("multipart/form-data")])]),t._v(" "),a("h3",{attrs:{id:"application-x-www-form-urlencoded"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#application-x-www-form-urlencoded"}},[t._v("#")]),t._v(" application/x-www-form-urlencoded")]),t._v(" "),a("ol",[a("li",[t._v("数据会被编码成以"),a("code",[t._v("&")]),t._v("分隔的键值对")]),t._v(" "),a("li",[t._v("字符串以"),a("strong",[t._v("URL")]),t._v("编码方式编码")])]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('// 转换过程: {a: 1, b: 2} -> a=1&b=2 -> 如下(最终形式)\n"a%3D1%26b%3D2"\n')])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("h3",{attrs:{id:"multipart-form-data"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#multipart-form-data"}},[t._v("#")]),t._v(" multipart/form-data")]),t._v(" "),a("ul",[a("li",[t._v("请求头中的"),a("strong",[t._v("Content-Type")]),t._v("字段会包含"),a("strong",[t._v("boundary")]),t._v("，且boundary的值有浏览器默认指定。例: "),a("code",[t._v("Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe")])]),t._v(" "),a("li",[t._v("数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如Content-Type，在最后的分隔符会加上--表示结束。")])]),t._v(" "),a("p",[t._v("请求体：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('Content-Disposition: form-data;name="data1";\nContent-Type: text/plain\ndata1\n----WebkitFormBoundaryRRJKeWfHPGrS4LKe\nContent-Disposition: form-data;name="data2";\nContent-Type: text/plain\ndata2\n----WebkitFormBoundaryRRJKeWfHPGrS4LKe--\n')])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("h3",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),a("p",[a("code",[t._v("multipart/form-data")]),t._v("格式最大的特点在于:"),a("strong",[t._v("每一个表单元素都是独立的资源表述")]),t._v("。")]),t._v(" "),a("p",[t._v("另外，你可能在写业务的过程中，并没有注意到其中还有boundary的存在，如果你打开抓包工具，确实可以看到不同的表单元素被拆分开了，之所以在平时感觉不到，是以为浏览器和 HTTP 给你封装了这一系列操作。")]),t._v(" "),a("p",[t._v("而且，在实际的场景中，对于图片等文件的上传，基本采用"),a("code",[t._v("multipart/form-data")]),t._v("而不用"),a("code",[t._v("application/x-www-form-urlencoded")]),t._v("，因为没有必要做 URL 编码，带来巨大耗时的同时也占用了更多的空间。")]),t._v(" "),a("h2",{attrs:{id:"十、http队头阻塞问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十、http队头阻塞问题"}},[t._v("#")]),t._v(" 十、HTTP队头阻塞问题")]),t._v(" "),a("p",[t._v("HTTP报文是一发一收，任务被放置在任务队列中执行，一旦队首的请求处理太慢，就会阻塞到后面请求的处理，这就是"),a("strong",[t._v("HTTP队头阻塞")]),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"并发连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发连接"}},[t._v("#")]),t._v(" 并发连接")]),t._v(" "),a("p",[t._v("一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队列的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。")]),t._v(" "),a("h3",{attrs:{id:"域名分卡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#域名分卡"}},[t._v("#")]),t._v(" 域名分卡")]),t._v(" "),a("p",[t._v("一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。")]),t._v(" "),a("p",[t._v("比如"),a("code",[t._v("content1.xxx.com")]),t._v("、"),a("code",[t._v("content2.xxx.com")])]),t._v(" "),a("p",[t._v("这样"),a("code",[t._v("xxx.com")]),t._v("下面可以分出非常多的二级域名，而它们指向统一服务器，能够并发的长连接增多了。")]),t._v(" "),a("h2",{attrs:{id:"十一、cookie"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十一、cookie"}},[t._v("#")]),t._v(" 十一、Cookie")]),t._v(" "),a("p",[t._v("HTTP是无状态协议，引入Cookie保存一些状态。")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 请求头\nCookie: a=xxx;b=xxx\n// 响应头\nSet-Cookie: a=xxx\nset-Cookie: b=xxx\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("h3",{attrs:{id:"cookie生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cookie生命周期"}},[t._v("#")]),t._v(" Cookie生命周期")]),t._v(" "),a("ul",[a("li",[t._v("Expires   //过期时间")]),t._v(" "),a("li",[t._v("Max-Age   //生效时长，从浏览器收到报文开始计算")])]),t._v(" "),a("h3",{attrs:{id:"作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[t._v("#")]),t._v(" 作用域")]),t._v(" "),a("p",[a("strong",[t._v("Domain")]),t._v("和"),a("strong",[t._v("Path")]),t._v("，绑定域名和路径。")]),t._v(" "),a("h3",{attrs:{id:"安全相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安全相关"}},[t._v("#")]),t._v(" 安全相关")]),t._v(" "),a("ul",[a("li",[t._v("HttpOnly  //设置只能通过HTTP协议传输获取，不能通过JS访问")]),t._v(" "),a("li",[t._v("SameSite  //Strict、Lax、None")])]),t._v(" "),a("h3",{attrs:{id:"cookie缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cookie缺点"}},[t._v("#")]),t._v(" Cookie缺点")]),t._v(" "),a("ol",[a("li",[t._v("容量太小")]),t._v(" "),a("li",[t._v("性能缺陷")]),t._v(" "),a("li",[t._v("安全缺陷")])]),t._v(" "),a("h2",{attrs:{id:"十二、http代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十二、http代理"}},[t._v("#")]),t._v(" 十二、HTTP代理")]),t._v(" "),a("p",[t._v("在客户端和服务器之间充当中间人的身份。对于客户端是接收方，对于源服务器是发送方。")]),t._v(" "),a("p",[t._v("功能：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("负载均衡")]),t._v("。保障各台源服务器负载平均。")]),t._v(" "),a("li",[a("strong",[t._v("保障安全")]),t._v("。利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。")]),t._v(" "),a("li",[a("strong",[t._v("缓存代理")]),t._v("。")])]),t._v(" "),a("h3",{attrs:{id:"相关头部字段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相关头部字段"}},[t._v("#")]),t._v(" 相关头部字段")]),t._v(" "),a("ul",[a("li",[t._v("Via： 记录经过的代理服务器，顺序即为在 HTTP 传输中报文传达的顺序。")]),t._v(" "),a("li",[t._v("X-Forwarded-For： 请求方的IP地址")]),t._v(" "),a("li",[t._v("X-Real-IP： 记录最初的客户端的IP")])]),t._v(" "),a("h2",{attrs:{id:"十三、代理缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十三、代理缓存"}},[t._v("#")]),t._v(" 十三、代理缓存")]),t._v(" "),a("h3",{attrs:{id:"为什么产生代理缓存？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么产生代理缓存？"}},[t._v("#")]),t._v(" 为什么产生代理缓存？")]),t._v(" "),a("p",[t._v("源服务器也有缓存，比如Redis, Memcache，但对于 HTTP 缓存来说，如果每次客户端缓存失效都要到源服务器获取，那给源服务器的压力是很大的。")]),t._v(" "),a("p",[t._v("因此引入了代理缓存，让"),a("strong",[t._v("代理服务器")]),t._v("接管一部分服务器的HTTP缓存。")]),t._v(" "),a("p",[t._v("客户端缓存过期后就近到代理缓存中获取，代理缓存过期了才请求源服务器")]),t._v(" "),a("p",[t._v("代理缓存的控制分为两部分：一是"),a("strong",[t._v("源服务器端")]),t._v("的控制，二是"),a("strong",[t._v("客户端")]),t._v("的控制。")]),t._v(" "),a("h3",{attrs:{id:"源服务器端的缓存控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#源服务器端的缓存控制"}},[t._v("#")]),t._v(" 源服务器端的缓存控制")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("public、private")]),t._v("   // 响应头中"),a("strong",[t._v("Cache-Control")]),t._v("加入，private或public表示是否允许代理服务器缓存。")]),t._v(" "),a("li",[t._v("proxy-revalidate  //"),a("code",[t._v("must-revalidate")]),t._v("的意思是客户端缓存过期就去源服务器获取，而p"),a("code",[t._v("roxy-revalidate")]),t._v("则表示代理服务器的缓存过期后到源服务器获取。")]),t._v(" "),a("li",[t._v("s-maxage  //限制了缓存在代理服务器中可以存放多久")])]),t._v(" "),a("h3",{attrs:{id:"客户端的缓存控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#客户端的缓存控制"}},[t._v("#")]),t._v(" 客户端的缓存控制")]),t._v(" "),a("ul",[a("li",[t._v("max-stale //对缓存进行宽容操作。"),a("code",[t._v("max-stale: 5")]),t._v("：只要过期时间在5秒之内，还是可以从代理中获取的。")]),t._v(" "),a("li",[t._v("min-fresh //对缓存进行限制操作。"),a("code",[t._v("min-fresh: 5")]),t._v("：不要等到缓存刚好到期再拿，一定要在到期前 5 秒之前的时间拿，否则拿不到。")]),t._v(" "),a("li",[t._v("only-if-cached  //表示客户端只接受代理缓存，不接受源服务器的缓存。如果代理缓存无效，直接返回"),a("strong",[t._v("504（Gateway Timeout）")])])]),t._v(" "),a("h2",{attrs:{id:"十四、跨域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十四、跨域"}},[t._v("#")]),t._v(" 十四、跨域")]),t._v(" "),a("p",[t._v("同源协议："),a("strong",[t._v("协议、主机、端口")]),t._v("都相同为同源。")]),t._v(" "),a("h3",{attrs:{id:"什么是跨域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是跨域"}},[t._v("#")]),t._v(" 什么是跨域")]),t._v(" "),a("p",[t._v("非同源即跨域有一定限制：")]),t._v(" "),a("ul",[a("li",[t._v("不能读取和修改DOM")]),t._v(" "),a("li",[t._v("不能访问Cookie、LocalStorage、SessionStorage、IndexDB...")]),t._v(" "),a("li",[t._v("限制XMLHttpRequest")])]),t._v(" "),a("p",[t._v("跨域请求的响应一般会被"),a("strong",[t._v("浏览器")]),t._v("所拦截，注意，是被浏览器拦截，响应其实是成功到达客户端了。")]),t._v(" "),a("p",[t._v("首先，浏览器是多进程的：\n"),a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/3/22/170ffd8131a4628f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}}),t._v(" "),a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/3/22/170ffd83a20647db?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}}),t._v(" "),a("strong",[t._v("WebKit 渲染引擎")]),t._v("和"),a("strong",[t._v("V8 引擎")]),t._v("都在渲染进程当中。")]),t._v(" "),a("p",[t._v("当"),a("code",[t._v("xhr.send")]),t._v("被调用，即"),a("code",[t._v("Ajax")]),t._v("请求准备发送的时候，其实还只是在"),a("strong",[t._v("渲染进程")]),t._v("的处理。为了防止黑客通过脚本触碰到系统资源，浏览器将每一个渲染进程装进了沙箱，并给每一个不同的站点（一级域名不同）分配了沙箱，互不干扰。")]),t._v(" "),a("p",[t._v("在沙箱当中的渲染进程是没有办法发送网络请求的，只能通过网络进程来发送。就涉及到进程间通信（IPC）。")]),t._v(" "),a("p",[t._v("现在数据传递给了浏览器主进程，主进程接收到后，才真正地发出相应的网络请求。在服务端处理完数据后，将响应返回，主进程检查到跨域，且没有"),a("strong",[t._v("cors")]),t._v("(后面会详细说)响应头，将响应体全部丢掉，并不会发送给渲染进程。这就达到了拦截数据的目的。")]),t._v(" "),a("h3",{attrs:{id:"cors"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cors"}},[t._v("#")]),t._v(" CORS")]),t._v(" "),a("p",[t._v("跨站资源共享，需要浏览器和服务器的共同支持。")]),t._v(" "),a("p",[t._v("分为"),a("strong",[t._v("简单请求")]),t._v("和"),a("strong",[t._v("非简单请求")])]),t._v(" "),a("h3",{attrs:{id:"简单请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简单请求"}},[t._v("#")]),t._v(" 简单请求")]),t._v(" "),a("p",[t._v("以下条件属于简单请求：")]),t._v(" "),a("ul",[a("li",[t._v("请求方法为 GET、POST 或者 HEAD")]),t._v(" "),a("li",[t._v("请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain)")])]),t._v(" "),a("p",[t._v("属于简单请求，自动在请求头中加入"),a("strong",[t._v("Origin")]),t._v("，说明来自哪个源。")]),t._v(" "),a("p",[t._v("服务器拿到请求之后，在回应时对应地添加"),a("strong",[t._v("Access-Control-Allow-Origin")]),t._v("字段，如果"),a("code",[t._v("Origin")]),t._v("不在这个字段的范围中，那么浏览器就会将响应拦截。")]),t._v(" "),a("p",[a("strong",[t._v("Access-Control-Allow-Credentials")]),t._v("：这个字段是一个布尔值，表示是否允许发送 Cookie，对于跨域请求，浏览器对这个字段默认值设为 false，而如果需要拿到浏览器的 Cookie，需要添加这个响应头并设为true, 并且在前端也需要设置withCredentials属性:")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let xhr = new XMLHttpRequest();\nxhr.withCredentials = true;\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("h3",{attrs:{id:"非简单请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#非简单请求"}},[t._v("#")]),t._v(" 非简单请求")]),t._v(" "),a("p",[t._v("非简单请求有两个不同："),a("strong",[t._v("预检请求")]),t._v("和"),a("strong",[t._v("响应字段")])]),t._v(" "),a("p",[t._v("以PUT方法为例：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var url = 'http://xxx.com';\nvar xhr = new XMLHttpRequest();\nxhr.open('PUT', url, true);\nxhr.setRequestHeader('X-Custom-Header', 'xxx');\nxhr.send();\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("p",[t._v("代码执行后，首先会执行预检请求：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("OPTIONS / HTTP/1.1\nOrigin: 当前地址\nHost: xxx.com\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: X-Custom-Header\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("p",[t._v("预检请求的方法是"),a("strong",[t._v("OPTIONS")]),t._v("，同时会加上"),a("code",[t._v("Origin")]),t._v("源地址和"),a("code",[t._v("Host")]),t._v("目标地址，这很简单。同时也会加上两个关键的字段:")]),t._v(" "),a("ul",[a("li",[t._v("Access-Control-Request-Method, 列出 CORS 请求用到哪个HTTP方法")]),t._v(" "),a("li",[t._v("Access-Control-Request-Headers，指定 CORS 请求将要加上什么请求头")])]),t._v(" "),a("p",[t._v("接下来是响应字段，分为两部分：")]),t._v(" "),a("ul",[a("li",[t._v("一部分是对于预检请求的响应")]),t._v(" "),a("li",[t._v("一部分是对于 CORS 请求的响应。")])]),t._v(" "),a("p",[t._v("预检请求的响应。如下面的格式:")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("HTTP/1.1 200 OK\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Methods: GET, POST, PUT\nAccess-Control-Allow-Headers: X-Custom-Header\nAccess-Control-Allow-Credentials: true\nAccess-Control-Max-Age: 1728000\nContent-Type: text/html; charset=utf-8\nContent-Encoding: gzip\nContent-Length: 0\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br")])]),a("ul",[a("li",[t._v("Access-Control-Allow-Origin: 表示可以允许请求的源，可以填具体的源名，也可以填*表示允许任意源请求。")]),t._v(" "),a("li",[t._v("Access-Control-Allow-Methods: 表示允许的请求方法列表。")]),t._v(" "),a("li",[t._v("Access-Control-Allow-Credentials: 这个字段是一个布尔值，表示是否允许发送 Cookie，对于跨域请求，浏览器对这个字段默认值设为 false。")]),t._v(" "),a("li",[t._v("Access-Control-Allow-Headers: 表示允许发送的请求头字段")]),t._v(" "),a("li",[t._v("Access-Control-Max-Age: 预检请求的有效期，在此期间，不用发出另外一条预检请求。")])]),t._v(" "),a("p",[t._v("在预检请求的响应返回后，如果请求不满足响应头的条件，则触发XMLHttpRequest的"),a("code",[t._v("onerror")]),t._v("方法，当然后面真正的CORS请求也不会发出去了。")]),t._v(" "),a("p",[t._v("CORS 请求的响应。绕了这么一大转，到了真正的 CORS 请求就容易多了，现在它和简单请求的情况是一样的。浏览器自动加上"),a("code",[t._v("Origin")]),t._v("字段，服务端响应头返回"),a("code",[t._v("Access-Control-Allow-Origin")]),t._v("。可以参考以上简单请求部分的内容。")]),t._v(" "),a("h3",{attrs:{id:"jsonp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsonp"}},[t._v("#")]),t._v(" JSONP")]),t._v(" "),a("p",[t._v("利用script的src不遵循同源协议，兼容性较好，但仅限于"),a("strong",[t._v("GET")]),t._v("请求。")]),t._v(" "),a("h3",{attrs:{id:"nginx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx"}},[t._v("#")]),t._v(" Nginx")]),t._v(" "),a("p",[t._v("Nginx 是一种高性能的反向代理服务器，可以用来轻松解决跨域问题。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/3/22/170ffd97d0b1cf15?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}}),t._v("\n正向代理帮助客户端访问客户端自己访问不到的服务器，然后将结果返回给客户端。")]),t._v(" "),a("p",[t._v("反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的负载均衡，换句话说，反向代理帮其它的服务器拿到请求，然后选择一个合适的服务器，将请求转交给它。")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("server {\n  listen  80;\n  server_name  client.com;\n  location /api {\n    proxy_pass server.com;\n  }\n}\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br")])]),a("h2",{attrs:{id:"十五、tls1-2握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十五、tls1-2握手"}},[t._v("#")]),t._v(" 十五、TLS1.2握手")]),t._v(" "),a("p",[t._v("HTTP是明文传输非常不安全，由此产生了HTTPS。")]),t._v(" "),a("p",[t._v("HTTPS是在HTTP下增加了一层SSL/TLS协议。简单来讲"),a("strong",[t._v("HTTPS = HTTP + SSL/TLS")])]),t._v(" "),a("p",[t._v("SSL 即安全套接层（Secure Sockets Layer），在 OSI 七层模型中处于会话层(第 5 层)。之前 SSL 出过三个大版本，当它发展到第三个大版本的时候才被标准化，成为 TLS（传输层安全，Transport Layer Security），并被当做 TLS1.0 的版本，准确地说，"),a("strong",[t._v("TLS1.0 = SSL3.1")]),t._v("。")]),t._v(" "),a("p",[t._v("现在TLS主流版本是1.2，之前的1.0和1.1都是不安全的。2018年推出了更优秀的1.3版本。")]),t._v(" "),a("h3",{attrs:{id:"传统rsa握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传统rsa握手"}},[t._v("#")]),t._v(" 传统RSA握手")]),t._v(" "),a("p",[t._v("传统的TLS握手就是RSA握手，是对称加密和非对称加密的结合，因为在加解密"),a("code",[t._v("pre_random")]),t._v("采用的是RSA算法所以成为RSA握手。\n"),a("img",{attrs:{src:"http://47.98.159.95/my_blog/week12/1.jpg",alt:""}})]),t._v(" "),a("ul",[a("li",[t._v("浏览器 -> 服务器： "),a("code",[t._v("client_random")]),t._v(" + 加密方法列表")]),t._v(" "),a("li",[t._v("服务器 -> 浏览器： "),a("code",[t._v("server_random")]),t._v(" + 加密方法 + 公钥")]),t._v(" "),a("li",[t._v("浏览器生成随机数"),a("strong",[t._v("pre_random")]),t._v("，并用公钥加密，传给服务器。")]),t._v(" "),a("li",[t._v("服务器用私钥解密，得到"),a("strong",[t._v("pre_random")])]),t._v(" "),a("li",[t._v("然后浏览器和服务器用一样的公钥进行通信，即对称加密。")])]),t._v(" "),a("p",[t._v("中间人没有私钥，拿不到"),a("strong",[t._v("pre_random")]),t._v("，无法生成最终的密钥。")]),t._v(" "),a("h3",{attrs:{id:"tls1-2握手过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tls1-2握手过程"}},[t._v("#")]),t._v(" TLS1.2握手过程")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/3/22/170ffd9b35c7a81b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}})]),t._v(" "),a("h4",{attrs:{id:"_1-step1-client-hello"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-step1-client-hello"}},[t._v("#")]),t._v(" 1:step1: Client Hello")]),t._v(" "),a("p",[t._v("首先，浏览器发送"),a("strong",[t._v("client_random")]),t._v("、TLS版本以及加密套件列表。")]),t._v(" "),a("p",[t._v("加密套件一般这样：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("TLS_ECDHE_WITH_AES_128_GCM_SHA256\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("blockquote",[a("p",[t._v("意思是TLS握手过程中，使用ECDHE算法生成pre_random(这个数后面会介绍)，128位的AES算法进行对称加密，在对称加密的过程中使用主流的GCM分组模式，因为对称加密中很重要的一个问题就是如何分组。最后一个是哈希摘要算法，采用SHA256算法。")])]),t._v(" "),a("h4",{attrs:{id:"_2-step2-server-hello"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-step2-server-hello"}},[t._v("#")]),t._v(" 2:step2: Server Hello")]),t._v(" "),a("p",[a("strong",[t._v("server_random")]),t._v("也是最后生成secret的一个参数, 同时确认 TLS 版本、需要使用的加密套件和自己的证书。")]),t._v(" "),a("h4",{attrs:{id:"_3-clinet验证证书，生成secret"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-clinet验证证书，生成secret"}},[t._v("#")]),t._v(" 3:Clinet验证证书，生成secret")]),t._v(" "),a("p",[t._v("客户端验证服务端传来的证书和签名是否通过，如果验证通过，则传递client_params这个参数给服务器。")]),t._v(" "),a("p",[t._v("接着客户端通过ECDHE算法计算出"),a("strong",[t._v("pre_random")]),t._v("，其中传入两个参数:"),a("code",[t._v("server_params")]),t._v("和"),a("code",[t._v("client_params")]),t._v("。现在你应该清楚这个两个参数的作用了吧，由于ECDHE基于椭圆曲线离散对数，这两个参数也称作椭圆曲线的公钥。")]),t._v(" "),a("p",[t._v("客户端现在拥有了"),a("code",[t._v("client_random")]),t._v("、"),a("code",[t._v("server_random")]),t._v("和"),a("code",[t._v("pre_random")]),t._v("，接下来将这三个数通过一个伪随机数函数来计算出最终的"),a("strong",[t._v("secret")]),t._v("。")]),t._v(" "),a("h4",{attrs:{id:"_4-server生成secret"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-server生成secret"}},[t._v("#")]),t._v(" 4:Server生成secret")]),t._v(" "),a("p",[t._v("现在服务端开始用ECDHE算法生成"),a("strong",[t._v("pre_random")]),t._v("，接着用和客户端同样的伪随机数函数生成最后的"),a("strong",[t._v("secret")]),t._v("。")]),t._v(" "),a("h4",{attrs:{id:"注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[t._v("#")]),t._v(" 注意事项")]),t._v(" "),a("ol",[a("li",[t._v("实际上 TLS 握手是一个双向认证的过程。step1：客户端有能力验证服务器的身份，step3:客户端发送"),a("code",[t._v("client_params")]),t._v("实际上给服务器传一个验证消息，让服务器将相同的验证流程(哈希摘要 + 私钥加密 + 公钥解密)走一遍，确认客户端的身份。")]),t._v(" "),a("li",[t._v("当客户端生成"),a("code",[t._v("secret")]),t._v("后，会给服务端发送一个收尾的消息，告诉服务器之后的都用对称加密，对称加密的算法就用第一次约定的。服务器生成完"),a("code",[t._v("secret")]),t._v("也会向客户端发送一个"),a("strong",[t._v("收尾")]),t._v("的消息，告诉客户端以后就直接用对称加密来通信。")])]),t._v(" "),a("p",[t._v("这个收尾的消息包括两部分，一部分是"),a("code",[t._v("Change Cipher Spec")]),t._v("，意味着后面加密传输了，另一个是"),a("code",[t._v("Finished")]),t._v("消息，这个消息是对之前所有发送的数据做的摘要，对摘要进行加密，让对方验证一下。")]),t._v(" "),a("p",[t._v("当双方都验证通过之后，握手才正式结束。后面的 HTTP 正式开始传输加密报文。")]),t._v(" "),a("h4",{attrs:{id:"rsa和ecdhe握手过程的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rsa和ecdhe握手过程的区别"}},[t._v("#")]),t._v(" RSA和ECDHE握手过程的区别")]),t._v(" "),a("ol",[a("li",[t._v("ECDHE 握手，也就是主流的 TLS1.2 握手中，使用ECDHE实现pre_random的加密解密，没有用到 RSA。")]),t._v(" "),a("li",[t._v("使用 ECDHE 还有一个特点，就是客户端发送完收尾消息后可以提前"),a("strong",[t._v("抢跑")]),t._v("，直接发送 HTTP 报文，节省了一个 RTT，不必等到收尾消息到达服务器，然后等服务器返回收尾消息给自己，直接开始发请求。这也叫TLS False Start。")])]),t._v(" "),a("h2",{attrs:{id:"十六、tls1-3做了哪些改进？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十六、tls1-3做了哪些改进？"}},[t._v("#")]),t._v(" 十六、TLS1.3做了哪些改进？")]),t._v(" "),a("p",[t._v("为了获得更强的安全、更优秀的性能，在2018年就推出了 TLS1.3，对于TLS1.2做了一系列的改进，主要分为这几个部分：")]),t._v(" "),a("ul",[a("li",[t._v("强化安全")]),t._v(" "),a("li",[t._v("提高性能")])]),t._v(" "),a("h3",{attrs:{id:"强化安全"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强化安全"}},[t._v("#")]),t._v(" 强化安全")]),t._v(" "),a("p",[t._v("在 TLS1.3 中废除了非常多的加密算法，最后只保留五个加密套件:")]),t._v(" "),a("ul",[a("li",[t._v("TLS_AES_128_GCM_SHA256")]),t._v(" "),a("li",[t._v("TLS_AES_256_GCM_SHA384")]),t._v(" "),a("li",[t._v("TLS_CHACHA20_POLY1305_SHA256")]),t._v(" "),a("li",[t._v("TLS_AES_128_GCM_SHA256")]),t._v(" "),a("li",[t._v("TLS_AES_128_GCM_8_SHA256\n最后剩下的对称加密算法只有 AES 和 CHACHA20，之前主流的也会这两种。分组模式也只剩下 GCM 和 POLY1305, 哈希摘要算法只剩下了 SHA256 和 SHA384 了。")])]),t._v(" "),a("p",[t._v("RSA非对称加密算法被取消了，原因有二：")]),t._v(" "),a("ol",[a("li",[t._v("2015年发现了FREAK攻击，即已经有人发现了 RSA 的漏洞，能够进行破解了。")]),t._v(" "),a("li",[t._v("一旦私钥泄露，那么中间人可以通过私钥计算出之前所有报文的secret，破解之前所有的密文。")])]),t._v(" "),a("p",[t._v("RSA握手当中，如果拿到了服务器私钥，就能拿到最终生成的会话密钥，每一个历史报文都能通过这样的方式进行破解。")]),t._v(" "),a("p",[t._v("但ECDHE在每次握手时都会生成临时的密钥对，即使私钥被破解，之前的历史消息并不会收到影响。这种一次破解并不影响历史信息的性质也叫"),a("strong",[t._v("前向安全性")]),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"提升性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提升性能"}},[t._v("#")]),t._v(" 提升性能")]),t._v(" "),a("h4",{attrs:{id:"握手改进"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#握手改进"}},[t._v("#")]),t._v(" 握手改进")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/3/22/170ffda75857d404?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}}),t._v("\n和 TLS 1.2 相比少了一个 RTT，服务器不必等待对方验证证书之后才拿到"),a("code",[t._v("client_params")]),t._v("，而是直接在第一次握手的时候就能够拿到, 拿到之后立即计算secret，节省了之前不必要的等待时间。")]),t._v(" "),a("p",[t._v("这种 TLS 1.3 握手方式也被叫做"),a("strong",[t._v("1-RTT握手")]),t._v("。")]),t._v(" "),a("p",[t._v("但还有优化的空间，主要是会话复用和PSK")]),t._v(" "),a("h4",{attrs:{id:"会话复用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#会话复用"}},[t._v("#")]),t._v(" 会话复用")]),t._v(" "),a("p",[t._v("会话复用有两种方式: "),a("strong",[t._v("Session ID")]),t._v("和"),a("strong",[t._v("Session Ticket")]),t._v("。")]),t._v(" "),a("p",[t._v("最早出现的"),a("strong",[t._v("Seesion ID")]),t._v("，具体做法是客户端和服务器首次连接后各自保存会话的 ID，并存储会话密钥，当再次连接时，客户端发送ID过来，服务器查找这个 ID 是否存在，如果找到了就直接复用之前的会话状态，会话密钥不用重新生成，直接用原来的那份。")]),t._v(" "),a("p",[t._v("但当客户端数量庞大的时候，对服务端的存储压力非常大。")]),t._v(" "),a("p",[t._v("因此出现了第二种方式："),a("strong",[t._v("Session Ticket")]),t._v("。双方连接成功后，服务器加密会话信息，用Session Ticket消息发给客户端，让客户端保存下来。下次重连的时候，就把这个 Ticket 进行解密，验证它过没过期，如果没过期那就直接恢复之前的会话状态。")]),t._v(" "),a("p",[t._v("这种方式虽然减小了服务端的存储压力，但与带来了安全问题，即每次用一个固定的密钥来解密 Ticket 数据，一旦黑客拿到这个密钥，之前所有的历史记录也被破解了。因此为了尽量避免这样的问题，密钥需要定期进行更换。")]),t._v(" "),a("h4",{attrs:{id:"psk"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#psk"}},[t._v("#")]),t._v(" PSK")]),t._v(" "),a("p",[t._v("还可以优化到"),a("code",[t._v("0-RTT")]),t._v("。")]),t._v(" "),a("p",[t._v("在发送Session Ticket的同时带上应用数据，不用等到服务端确认，这种方式被称为"),a("code",[t._v("Pre-Shared Key")]),t._v("，即 "),a("strong",[t._v("PSK")]),t._v("。")]),t._v(" "),a("p",[t._v("这种方式虽然方便，但也带来了安全问题。中间人截获PSK的数据，不断向服务器重复发，类似于 TCP 第一次握手携带数据，增加了服务器被攻击的风险。")]),t._v(" "),a("h4",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("TLS1.3 在 TLS1.2 的基础上废除了大量的算法，提升了安全性。同时利用会话复用节省了重新生成密钥的时间，利用 PSK 做到了0-RTT连接。")]),t._v(" "),a("h2",{attrs:{id:"十七、http-2的改进"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十七、http-2的改进"}},[t._v("#")]),t._v(" 十七、HTTP/2的改进")]),t._v(" "),a("p",[t._v("HTTPS已经将安全做的足够好，HTTP/2改进的是性能，主要有两方面：")]),t._v(" "),a("ul",[a("li",[t._v("头部压缩")]),t._v(" "),a("li",[t._v("多路复用")])]),t._v(" "),a("p",[t._v("还有一些新增功能：")]),t._v(" "),a("ul",[a("li",[t._v("设置请求优先级")]),t._v(" "),a("li",[t._v("服务器推送")])]),t._v(" "),a("h3",{attrs:{id:"头部压缩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#头部压缩"}},[t._v("#")]),t._v(" 头部压缩")]),t._v(" "),a("p",[t._v("HTTP/1.1及之前，指定"),a("strong",[t._v("Content-Encoding")]),t._v("可将请求体压缩。")]),t._v(" "),a("p",[t._v("HTTP/2针对头部字段，采用了"),a("strong",[t._v("HPACK算法")]),t._v("压缩。")]),t._v(" "),a("p",[t._v("HPACK主要有两个亮点：")]),t._v(" "),a("ol",[a("li",[t._v("浏览器和服务器之间建立一个哈希表，将用过的相关字段存入，传输过程直接使用"),a("strong",[t._v("索引")]),t._v("。\n"),a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/3/22/170ffdaa6f41c004?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}})])]),t._v(" "),a("blockquote",[a("p",[t._v('HTTP/2 当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个":"前缀，用来和其它请求头区分开。')])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("对于整数和字符进行"),a("strong",[t._v("哈夫曼编码")]),t._v("。先将所有出现的字符建立一张索引表，然后让出现次数较多的索引尽可能短。")])]),t._v(" "),a("h3",{attrs:{id:"多路复用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多路复用"}},[t._v("#")]),t._v(" 多路复用")]),t._v(" "),a("p",[t._v("HTTP队头阻塞的问题根本在于HTTP基于"),a("strong",[t._v("请求-响应")]),t._v("模型。在同一个TCP连接中，前面的请求没有得到响应，后面的请求就会被阻塞。")]),t._v(" "),a("p",[t._v("HTTP的明文传输效率比较低，HTTP/2将报文全部替换为"),a("strong",[t._v("二进制格式")]),t._v("，方便机器解析。")]),t._v(" "),a("p",[t._v("原来的"),a("code",[t._v("Header+Body")]),t._v("如今被拆分为了一个一个二进制帧，用"),a("strong",[t._v("Header帧")]),t._v("存放头部字段，用"),a("strong",[t._v("Data帧")]),t._v("存放请求体字段。分帧后，服务器看到的是一堆乱序的二进制帧，就不存在先后关系也不会排队等待，就没了HTTP队头阻塞问题。")]),t._v(" "),a("p",[t._v("通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，也叫做"),a("strong",[t._v("流(Stream)")]),t._v("。HTTP/2 用流来在一个 TCP 连接上来进行多个数据帧的通信，这就是"),a("strong",[t._v("多路复用")]),t._v("的概念。")]),t._v(" "),a("p",[t._v("所谓乱序，是指不同ID的Stream是乱序的，但同一个 Stream ID 的帧一定是按顺序传输的。二进制帧到达后对方会将 "),a("strong",[t._v("Stream ID")]),t._v(" 相同的二进制帧组装成完整的请求报文和响应报文。")]),t._v(" "),a("h3",{attrs:{id:"服务器推送"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务器推送"}},[t._v("#")]),t._v(" 服务器推送")]),t._v(" "),a("p",[t._v("HTTP/2也能新建stream来给客户端发送消息。")]),t._v(" "),a("p",[t._v("当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。")]),t._v(" "),a("h3",{attrs:{id:"小结-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结-2"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),a("p",[t._v("HTTP/2完全兼容之前的HTTP的语法和语义，如请求头、状态码、头部字段都没有改变。")]),t._v(" "),a("p",[t._v("此外，在安全方面，HTTP/2也支持TLS，并且现在主流的浏览器都公开只支持加密的 HTTP/2, 因此你现在能看到的 HTTP/2 也基本上都是跑在 TLS 上面的了。\n"),a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/3/22/170ffdc6783132a5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"十八、http-2中的二进制帧"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十八、http-2中的二进制帧"}},[t._v("#")]),t._v(" 十八、HTTP/2中的二进制帧")]),t._v(" "),a("h3",{attrs:{id:"帧结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#帧结构"}},[t._v("#")]),t._v(" 帧结构")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/3/22/170ffdc9e9c25e93?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}}),t._v("\n帧分为帧头和帧体。")]),t._v(" "),a("ul",[a("li",[t._v("显示3个字节的帧长度，表示的是帧体的长度。")]),t._v(" "),a("li",[t._v("帧类型。数据帧和控制帧两种。数据帧用来存放 HTTP 报文，控制帧用来管理流的传输。")]),t._v(" "),a("li",[t._v("帧标志。里面一共有 8 个标志位，常用的有 END_HEADERS表示头数据结束，END_STREAM表示单方向数据发送结束。")]),t._v(" "),a("li",[t._v("流标识符。接收方就能从乱序的二进制帧中选择出 ID 相同的帧，按顺序组装成请求/响应报文。")])]),t._v(" "),a("h3",{attrs:{id:"流的状态变化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流的状态变化"}},[t._v("#")]),t._v(" 流的状态变化")]),t._v(" "),a("p",[t._v("在HTTP中，流就是"),a("strong",[t._v("二进制的双向传输的序列")]),t._v("。")]),t._v(" "),a("p",[t._v("流的状态改变借鉴了TCP状态变化的思想，根据"),a("strong",[t._v("帧的标志位")]),t._v("来实现具体的状态改变。\n"),a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/3/22/170ffdcd0abdd1ba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}})]),t._v(" "),a("p",[t._v("如果下次要开启新的流，流ID自增，直到上限为止，到达上限后开一个新的 TCP 连接重头开始计数。由于流 ID 字段长度为 4 个字节，最高位又被保留，因此范围是 0 ~ 2的 31 次方，大约 21 亿个。")]),t._v(" "),a("h3",{attrs:{id:"流特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流特性"}},[t._v("#")]),t._v(" 流特性")]),t._v(" "),a("p",[t._v("流的传输特性：")]),t._v(" "),a("ol",[a("li",[t._v("并发性。一个 HTTP/2 连接上可以同时发多个帧，这一点和 HTTP/1 不同。这也是实现"),a("strong",[t._v("多路复用")]),t._v("的基础。")]),t._v(" "),a("li",[t._v("自增性。流 ID 是不可重用的，而是会按顺序递增，达到上限之后又新开 TCP 连接从头开始。")]),t._v(" "),a("li",[t._v("双向性。客户端和服务端都可以创建流，互不干扰，双方都可以作为发送方或者接收方。")]),t._v(" "),a("li",[t._v("可设置优先级。可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);