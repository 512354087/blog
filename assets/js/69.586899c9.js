(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{702:function(s,e,n){"use strict";n.r(e);var a=n(76),t=Object(a.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("p",[s._v("-- 前言")]),s._v(" "),e("p",[s._v("2020 年了，nodejs 和浏览器基本都支持了原生 esm，那么现在 js 库该怎么写？本文先解释他们分别是什么，再结合最新环境支持给出建议和实践。")]),s._v(" "),e("h2",{attrs:{id:"cjs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cjs"}},[s._v("#")]),s._v(" CJS")]),s._v(" "),e("p",[s._v('CommonJS，只能在 NodeJS 上运行，使用 require("module") 读取并加载模块。')]),s._v(" "),e("p",[s._v("缺点：不支持浏览器，执行后才能拿到依赖信息，由于用户可以动态 require（例如 react 根据开发和生产环境导出不同代码 的写法），无法做到提前分析依赖以及 Tree-Shaking 。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("// sum.js\nexports.sum = (x, y) => x + y\n\n// index.js\nconst { sum } = require('./sum.js')\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("h2",{attrs:{id:"amd"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#amd"}},[s._v("#")]),s._v(" AMD")]),s._v(" "),e("p",[s._v("Asynchronous Module Definition，可以看作 CJS 的异步版本，制定了一套规则使模块可以被异步 require 进来并在回调函数里继续使用，然后 require.js 等前端库也可以利用这个规则加载代码了，目前已经是时代的眼泪了。")]),s._v(" "),e("h2",{attrs:{id:"umd"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#umd"}},[s._v("#")]),s._v(" UMD")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("Universal Module Definition，同时兼容 CJS 和 AMD，并且支持直接在前端用 <script src=\"lib.umd.js\"><\/script> 的方式加载。现在还在广泛使用，不过可以想象 ESM 和 IIFE 逐渐代替它。\n\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['jquery'], factory);\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = factory(require('jquery'));\n  } else {\n    // 全局变量\n    root.returnExports = factory(root.jQuery);\n  }\n}(this, function ($) {\n  // ...\n}));\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br")])]),e("h2",{attrs:{id:"iife-立即调用函数表达式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#iife-立即调用函数表达式"}},[s._v("#")]),s._v(" IIFE(立即调用函数表达式)")]),s._v(" "),e("p",[s._v("Immediately Invoked Function Expression，只是一种写法，可以隐藏一些局部变量，前端人要是不懂这个可能学的是假前端。可以用来代替 UMD 作为纯粹给前端使用的写法。")]),s._v(" "),e("h2",{attrs:{id:"esm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#esm"}},[s._v("#")]),s._v(" ESM")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('ECMAScript Module，现在使用的模块方案，使用 import export 来管理依赖。由于它们只能写在所有表达式外面，所以打包器可以轻易做到分析依赖以及 Tree-Shaking。当然他也支持动态加载（import()）。浏览器直接通过 <script type="module"> 即可使用该写法。NodeJS 可以通过使用 mjs 后缀或者在 package.json 添加 "type": "module" 来使用，注意他还有一些 实验性的功能 没有正式开启。考虑到大量 cjs 库没有支持，如果要发布 esm 版的库还是通过 rollup 打包一下比较好（同时相关依赖可以放到 devDependencies 里）。\n\n\n// sum.js\nexport const sum = (x, y) => x + y\n\n// index.js\nimport { sum } from \'./sum\'\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br")])])])}),[],!1,null,null,null);e.default=t.exports}}]);