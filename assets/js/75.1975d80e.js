(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{705:function(s,e,n){"use strict";n.r(e);var t=n(76),a=Object(t.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"promise-对象有以下两个特点。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-对象有以下两个特点。"}},[s._v("#")]),s._v(" Promise 对象有以下两个特点。")]),s._v(" "),e("p",[s._v("（1）对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。")]),s._v(" "),e("p",[s._v("（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。 Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected")]),s._v(" "),e("h2",{attrs:{id:"promise-prototype-then"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-then"}},[s._v("#")]),s._v(" Promise.prototype.then()")]),s._v(" "),e("p",[s._v("then 方法返回的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('  getJSON("/posts.json").then(function(json) {\n    return json.post;\n  }).then(function(post) {\n    // ...\n  });\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("h2",{attrs:{id:"promise-prototype-catch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-catch"}},[s._v("#")]),s._v(" Promise.prototype.catch()")]),s._v(" "),e("p",[s._v("Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。")]),s._v(" "),e("p",[s._v("如果 Promise 状态已经变成 resolved，再抛出错误是无效的。")]),s._v(" "),e("p",[s._v("Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("getJSON('/post/1.json').then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // some code\n}).catch(function(error) {\n  // 处理前面三个Promise产生的错误\n});\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br")])]),e("p",[s._v("上面代码中，一共有三个 Promise 对象：一个由 getJSON()产生，两个由 then()产生。它们之中任何一个抛出的错误，都会被最后一个 catch()捕获。")]),s._v(" "),e("h2",{attrs:{id:"promise-prototype-finally"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-finally"}},[s._v("#")]),s._v(" Promise.prototype.finally()")]),s._v(" "),e("p",[s._v("finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("    promise\n    .then(result => {···})\n    .catch(error => {···})\n    .finally(() => {···});\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("h2",{attrs:{id:"promise-all"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-all"}},[s._v("#")]),s._v(" Promise.all()")]),s._v(" "),e("p",[s._v("Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v(" const p = Promise.all([p1, p2, p3]);\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("（1）只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。")]),s._v(" "),e("p",[s._v("（2）只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("  const p1 = new Promise((resolve, reject) => {\n  resolve('hello');\n    })\n    .then(result => result);\n\n    const p2 = new Promise((resolve, reject) => {\n      throw new Error('报错了');\n    })\n    .then(result => result);\n\n    Promise.all([p1, p2])\n    .then(result => console.log(result))\n    .catch(e => console.log(e));\n    // Error: 报错了\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br")])]),e("p",[s._v("如果作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected，并不会触发 Promise.all()的 catch 方法。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("  const p1 = new Promise((resolve, reject) => {\n    resolve('hello');\n  }).then(result => result).catch(e => e);\n\n  const p2 = new Promise((resolve, reject) => {\n    throw new Error('报错了');\n  }).then(result => result).catch(e => e);\n\n  Promise.all([p1, p2]).then(result => console.log(result)).catch(e => console.log(e));\n  // [\"hello\", Error: 报错了]\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br")])]),e("h2",{attrs:{id:"promise-race"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-race"}},[s._v("#")]),s._v(" Promise.race()")]),s._v(" "),e("p",[s._v("romise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。")]),s._v(" "),e("p",[s._v("上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("  const p = Promise.race([p1, p2, p3]);\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h2",{attrs:{id:"promise-allsettled"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-allsettled"}},[s._v("#")]),s._v(" Promise.allSettled()")]),s._v(" "),e("p",[s._v("Promise.allSettled()方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是fulfilled还是rejected），返回的 Promise 对象才会发生状态变更。")]),s._v(" "),e("p",[s._v("该方法返回的新的 Promise 实例，一旦发生状态变更，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 Promise 对象。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("  const resolved = Promise.resolve(42);\n  const rejected = Promise.reject(-1);\n\n  const allSettledPromise = Promise.allSettled([resolved, rejected]);\n\n  allSettledPromise.then(function (results) {\n    console.log(results);\n  });\n  // [\n  //    { status: 'fulfilled', value: 42 },\n  //    { status: 'rejected', reason: -1 }\n  // ]\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br")])]),e("h2",{attrs:{id:"promise-any"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-any"}},[s._v("#")]),s._v(" Promise.any()")]),s._v(" "),e("p",[s._v("只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。")]),s._v(" "),e("p",[s._v("Promise.any()跟Promise.race()方法很像，只有一点不同，就是Promise.any()不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("  const promises = [\n    fetch('/endpoint-a').then(() => 'a'),\n    fetch('/endpoint-b').then(() => 'b'),\n    fetch('/endpoint-c').then(() => 'c'),\n  ];\n\n  try {\n    const first = await Promise.any(promises);\n    console.log(first);\n  } catch (error) {\n    console.log(error);\n  }\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br")])])])}),[],!1,null,null,null);e.default=a.exports}}]);